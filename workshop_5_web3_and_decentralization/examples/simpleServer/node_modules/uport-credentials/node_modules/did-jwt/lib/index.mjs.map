{"version":3,"file":"index.mjs","sources":["../src/Digest.ts","../src/SimpleSigner.ts","../src/util.ts","../src/NaclSigner.ts","../src/VerifierAlgorithm.ts","../src/SignerAlgorithm.ts","../src/JWT.ts"],"sourcesContent":["import { sha256 as sha256js, Message } from 'js-sha256'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\nimport { Buffer } from 'buffer'\n\nexport function sha256 (payload: Message): Buffer {\n  return Buffer.from(sha256js.arrayBuffer(payload))\n}\n\nexport function keccak (data: Message): Buffer {\n  return Buffer.from(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress (hexPublicKey: string): string {\n  return `0x${keccak(Buffer.from(hexPublicKey.slice(2), 'hex')).slice(-20).toString('hex')}`\n}\n","import { ec as EC, ec } from 'elliptic'\nimport { sha256 } from './Digest'\nimport { Signer } from './JWT'\n\nconst secp256k1: EC = new EC('secp256k1')\n\nfunction leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n/**\n *  The SimpleSigner returns a configured function for signing data. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  const privateKey: ec.KeyPair = secp256k1.keyFromPrivate(hexPrivateKey)\n  return async data => {\n    const { r, s, recoveryParam }: EC.Signature = privateKey.sign(sha256(data))\n    return {\n      r: leftpad(r.toString('hex')),\n      s: leftpad(s.toString('hex')),\n      recoveryParam\n    }\n  }\n}\n\nexport default SimpleSigner\n","export function base64ToBytes(s: string): Uint8Array {\n  return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0))\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return Buffer.from(b).toString('base64')\n}\n","import nacl from 'tweetnacl'\nimport { encode } from '@stablelib/utf8'\nimport { Buffer } from 'buffer'\nimport { Signer } from './JWT'\nimport { base64ToBytes } from './util'\nimport base64url from 'uport-base64url'\n\n/**\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  The signing function itself takes the data as a string parameter and returls a base64Url encoded signature\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  const privateKey: Uint8Array = base64ToBytes(base64PrivateKey)\n  return async data => {\n    const dataBytes: Uint8Array = encode(data)\n    const sig: Uint8Array = nacl.sign.detached(dataBytes, privateKey)\n    const b64UrlSig: string = base64url.encode(Buffer.from(sig))\n    return b64UrlSig\n  }\n}\n\nexport default NaclSigner\n","import { ec as EC } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport base64url from 'uport-base64url'\nimport nacl from 'tweetnacl'\nimport { EcdsaSignature } from './JWT'\nimport { PublicKey } from 'did-resolver'\nimport { encode } from '@stablelib/utf8'\nimport { base64ToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(\n  signature: string,\n  recoverable = false\n): EcdsaSignature {\n  const rawsig: Buffer = base64url.toBuffer(signature)\n  if (rawsig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = rawsig.slice(0, 32).toString('hex')\n  const s: string = rawsig.slice(32, 64).toString('hex')\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64]\n  }\n  return sigObj\n}\n\nexport function verifyES256K(\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n): PublicKey {\n  const hash: Buffer = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const signer: PublicKey = authenticators.find(({ publicKeyHex }) =>\n    secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj)\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n): PublicKey {\n  const sigObj: EcdsaSignature = toSignatureObject(signature, true)\n  const hash: Buffer = sha256(data)\n  // what type is recoveredKey supposed to be?\n  const recoveredKey: any = secp256k1.recoverPubKey(\n    hash,\n    sigObj,\n    sigObj.recoveryParam\n  )\n  const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n  const recoveredCompressedPublicKeyHex: string = recoveredKey.encode(\n    'hex',\n    true\n  )\n  const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n  const signer: PublicKey = authenticators.find(\n    ({ publicKeyHex, ethereumAddress }) =>\n      publicKeyHex === recoveredPublicKeyHex ||\n      publicKeyHex === recoveredCompressedPublicKeyHex ||\n      ethereumAddress === recoveredAddress\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyEd25519(\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n): PublicKey {\n  const clear: Uint8Array = encode(data)\n  const sig: Uint8Array = base64ToBytes(base64url.toBase64(signature))\n  const signer: PublicKey = authenticators.find(({ publicKeyBase64 }) =>\n    nacl.sign.detached.verify(\n      clear,\n      sig,\n      base64ToBytes(publicKeyBase64)\n    )\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n) => PublicKey\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  'ES256K-R': verifyRecoverableES256K,\n  Ed25519: verifyEd25519\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import base64url from 'uport-base64url'\nimport { Buffer } from 'buffer'\nimport { Signer, EcdsaSignature, SignerAlgorithm } from './JWT'\n\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSigner(recoverable?: boolean): SignerAlgorithm {\n  function toJose({ r, s, recoveryParam }: EcdsaSignature): string {\n    const jose: Buffer = Buffer.alloc(recoverable ? 65 : 64)\n    Buffer.from(r, 'hex').copy(jose, 0)\n    Buffer.from(s, 'hex').copy(jose, 32)\n    if (recoverable) {\n      if (recoveryParam === undefined) {\n        throw new Error('Signer did not return a recoveryParam')\n      }\n      jose[64] = recoveryParam\n    }\n    return base64url.encode(jose)\n  }\n\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature)\n    } else {\n      throw new Error(\n        'expected a signer function that returns a signature object instead of string'\n      )\n    }\n  }\n}\n\nexport function Ed25519Signer(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error(\n        'expected a signer function that returns a string instead of signature object'\n      )\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSigner(),\n  'ES256K-R': ES256KSigner(true),\n  Ed25519: Ed25519Signer()\n}\n\nfunction SignerAlgorithm(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlgorithm\n","import VerifierAlgorithm from './VerifierAlgorithm'\nimport SignerAlgorithm from './SignerAlgorithm'\nimport base64url from 'uport-base64url'\nimport resolve, { DIDDocument, PublicKey } from 'did-resolver'\n\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number\n}\n\nexport type Signer = (data: string) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (\n  payload: string,\n  signer: Signer\n) => Promise<string>\n\ninterface JWTOptions {\n  issuer: string\n  signer: Signer\n  alg?: string\n  expiresIn?: number\n}\n\ninterface JWTVerifyOptions {\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n}\n\ninterface DIDAuthenticator {\n  authenticators: PublicKey[]\n  issuer: string\n  doc: DIDDocument\n}\n\ninterface JWTHeader {\n  typ: 'JWT'\n  alg: string\n}\n\ninterface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string\n  iat?: number\n  type?: string\n  exp?: number\n  rexp?: number\n}\n\ninterface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\ninterface Verified {\n  payload: any\n  doc: DIDDocument\n  issuer: string\n  signer: object\n  jwt: string\n}\n\ninterface PublicKeyTypes {\n  [name: string]: string[]\n}\nconst SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: [\n    'Secp256k1VerificationKey2018',\n    'Secp256k1SignatureVerificationKey2018',\n    'EcdsaPublicKeySecp256k1'\n  ],\n  'ES256K-R': [\n    'Secp256k1VerificationKey2018',\n    'Secp256k1SignatureVerificationKey2018',\n    'EcdsaPublicKeySecp256k1'\n  ],\n  Ed25519: ['ED25519SignatureVerification']\n}\n\nconst JOSE_HEADER = { typ: 'JWT' }\nconst defaultAlg = 'ES256K'\n\nfunction encodeSection(data: any): string {\n  return base64url.encode(JSON.stringify(data))\n}\n\nexport const IAT_SKEW: number = 300\n\n/**  @module did-jwt/JWT */\n\nfunction isMNID(id: string): RegExpMatchArray {\n  return id.match(\n    /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/\n  )\n}\n\nfunction isDIDOrMNID(mnidOrDid: string): RegExpMatchArray {\n  return mnidOrDid && (mnidOrDid.match(/^did:/) || isMNID(mnidOrDid))\n}\n\nexport function normalizeDID(mnidOrDid: string): string {\n  if (mnidOrDid.match(/^did:/)) return mnidOrDid\n  // Backwards compatibility\n  if (isMNID(mnidOrDid)) return `did:uport:${mnidOrDid}`\n  throw new Error(`Not a valid DID '${mnidOrDid}'`)\n}\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('no JWT passed into decodeJWT')\n  const parts: RegExpMatchArray = jwt.match(\n    /^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/\n  )\n  if (parts) {\n    return {\n      header: JSON.parse(base64url.decode(parts[1])),\n      payload: JSON.parse(base64url.decode(parts[2])),\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`\n    }\n  }\n  throw new Error('Incorrect format JWT')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload            payload object\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg         The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K\n *  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js\n *  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error\n */\n// export async function createJWT(payload, { issuer, signer, alg, expiresIn }) {\nexport async function createJWT(\n  payload: object,\n  { issuer, signer, alg, expiresIn }: JWTOptions\n): Promise<string> {\n  if (!signer) throw new Error('No Signer functionality has been configured')\n  if (!issuer) throw new Error('No issuing DID has been configured')\n  const header: JWTHeader = { typ: 'JWT', alg: alg || defaultAlg }\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = timestamps.iat + Math.floor(expiresIn)\n    } else {\n      throw new Error('JWT expiresIn is not a number')\n    }\n  }\n  const signingInput: string = [\n    encodeSection(header),\n    encodeSection({ ...timestamps, ...payload, iss: issuer })\n  ].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlgorithm(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = { auth: null, audience: null, callbackUrl: null }\n): Promise<Verified> {\n  const aud: string = options.audience\n    ? normalizeDID(options.audience)\n    : undefined\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const {\n    doc,\n    authenticators,\n    issuer\n  }: DIDAuthenticator = await resolveAuthenticator(\n    header.alg,\n    payload.iss,\n    options.auth\n  )\n  const signer: PublicKey = VerifierAlgorithm(header.alg)(\n    data,\n    signature,\n    authenticators\n  )\n  const now: number = Math.floor(Date.now() / 1000)\n  if (signer) {\n    if (payload.iat && payload.iat > now + IAT_SKEW) {\n      throw new Error(\n        `JWT not valid yet (issued in the future): iat: ${\n          payload.iat\n        } > now: ${now}`\n      )\n    }\n    if (payload.exp && payload.exp <= now - IAT_SKEW) {\n      throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (isDIDOrMNID(payload.aud)) {\n        if (!aud) {\n          throw new Error(\n            'JWT audience is required but your app address has not been configured'\n          )\n        }\n\n        if (aud !== normalizeDID(payload.aud)) {\n          throw new Error(\n            `JWT audience does not match your DID: aud: ${\n              payload.aud\n            } !== yours: ${aud}`\n          )\n        }\n      } else {\n        if (!options.callbackUrl) {\n          throw new Error(\n            \"JWT audience matching your callback url is required but one wasn't passed in\"\n          )\n        }\n        if (payload.aud !== options.callbackUrl) {\n          throw new Error(\n            `JWT audience does not match the callback url: aud: ${\n              payload.aud\n            } !== url: ${options.callbackUrl}`\n          )\n        }\n      }\n    }\n    return { payload, doc, issuer, signer, jwt }\n  }\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator('ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  alg: string,\n  mnidOrDid: string,\n  auth?: boolean\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`No supported signature types for algorithm ${alg}`)\n  }\n  const issuer: string = normalizeDID(mnidOrDid)\n  const doc: DIDDocument = await resolve(issuer)\n  if (!doc) throw new Error(`Unable to resolve DID document for ${issuer}`)\n  // is there some way to have authenticationKeys be a single type?\n  const authenticationKeys: boolean | string[] = auth\n    ? (doc.authentication || []).map(({ publicKey }) => publicKey)\n    : true\n  const authenticators: PublicKey[] = (doc.publicKey || []).filter(\n    ({ type, id }) =>\n      types.find(\n        supported =>\n          supported === type &&\n          (!auth ||\n            (Array.isArray(authenticationKeys) &&\n              authenticationKeys.indexOf(id) >= 0))\n      )\n  )\n\n  if (auth && (!authenticators || authenticators.length === 0)) {\n    throw new Error(\n      `DID document for ${issuer} does not have public keys suitable for authenticationg user`\n    )\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(\n      `DID document for ${issuer} does not have public keys for ${alg}`\n    )\n  }\n  return { authenticators, issuer, doc }\n}"],"names":["sha256","payload","Buffer","from","sha256js","arrayBuffer","toEthereumAddress","hexPublicKey","data","slice","keccak_256","toString","secp256k1","EC","leftpad","size","length","repeat","SimpleSigner","hexPrivateKey","privateKey","keyFromPrivate","sign","r","s","recoveryParam","base64ToBytes","Uint8Array","Array","prototype","call","NaclSigner","base64PrivateKey","dataBytes","encode","sig","nacl","detached","b64UrlSig","base64url","const","toSignatureObject","signature","recoverable","rawsig","toBuffer","Error","sigObj","algorithms","ES256K","authenticators","hash","signer","find","ref","keyFromPublic","verify","recoveredKey","recoverPubKey","recoveredPublicKeyHex","recoveredCompressedPublicKeyHex","recoveredAddress","publicKeyHex","Ed25519","clear","toBase64","VerifierAlgorithm","alg","impl","instanceOfEcdsaSignature","object","ES256KSigner","jose","alloc","copy","undefined","toJose","verifyJWT","jwt","options","auth","audience","callbackUrl","aud","normalizeDID","decodeJWT","mnidOrDid","types","SUPPORTED_PUBLIC_KEY_TYPES","issuer","resolve","doc","authenticationKeys","authentication","map","publicKey","filter","supported","type","isArray","indexOf","id","resolveAuthenticator","header","iss","now","Math","floor","Date","iat","IAT_SKEW","exp","match","isMNID","createJWT","typ","defaultAlg","timestamps","expiresIn","signingInput","encodeSection","Object","join","jwtSigner","SignerAlgorithm","JSON","stringify","parts","parse","decode"],"mappings":"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"}