{"version":3,"file":"index.js","sources":["../src/Contract.ts","../src/Credentials.ts"],"sourcesContent":["\n// A derivative work of Nick Dodson's eths-contract https://github.com/ethjs/ethjs-contract/blob/master/src/index.js\n\nexport interface TransactionRequest {\n  from?: string,\n  to?: string,\n  data?: string,\n  value?: string | number,\n  gasPrice?: string | number,\n  gas?: string | number\n  fn?: string\n  function?: string\n}\n\nexport enum AbiEntryType {\n  Function = 'function',\n  Event = 'event',\n  Constructor = 'constructor',\n  Fallback = 'fallback'\n}\n\nenum StateMutability {\n  Pure = 'pure',\n  View = 'view',\n  NonPayable = 'nonpayable',\n  Payable = 'payable'\n}\n\nexport interface AbiParam {\n  name: string,\n  type: string,\n  components?: AbiParam[]\n}\n\ninterface AbiEntry {\n  type: AbiEntryType,\n  name?: string,\n  inputs?: AbiParam[],\n}\n\nexport interface AbiFunction extends AbiEntry {\n  // type: AbiEntryType.Function | AbiEntryType.Constructor | AbiEntryType.Constructor,\n  outputs?: AbiParam[],\n  stateMutability?: StateMutability,\n  payable?: true\n  constant?: true\n}\n\ninterface AbiEventParam extends AbiParam {\n  indexed?: boolean\n}\n\nexport interface AbiEvent extends AbiEntry {\n  // type: AbiEntryType.Event,\n  inputs?: AbiEventParam[],\n  anonymous?: boolean\n}\n\nexport type ContractABI = Array<AbiEvent|AbiFunction>\n\nconst isTransactionObject = (txObj: TransactionRequest) => {\n  const txObjectProperties = ['from', 'to', 'data', 'value', 'gasPrice', 'gas']\n  if (typeof txObj !== 'object') return false\n  // Return true for empty object\n  if (Object.keys(txObj).length === 0) return true\n  // Also return true if the object contains any of the expected txObject properties\n  for (const prop of txObjectProperties) {\n    if (prop in txObj) return true\n  }\n\n  return false;\n}\n\nconst getCallableMethodsFromABI = (contractABI: ContractABI): AbiFunction[] => {\n  return <AbiFunction[]>contractABI.filter((entry) => (entry.type === AbiEntryType.Function && entry.name && (!(<AbiFunction>entry).constant)));\n}\n\nconst encodeMethodReadable = (methodObject: AbiFunction, methodArgs: any[]) => {\n  let dataString = `${methodObject.name}(`\n  const inputs = methodObject.inputs || []\n\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i]\n    let argString = `${input.type} `\n\n    if (input.type === 'string') {\n      argString += `\"${methodArgs[i]}\"`\n    } else if (input.type === ('bytes32' || 'bytes')) {\n      // TODO don't assume hex input? or throw error if not hex\n      // argString += `0x${new Buffer(methodArgs[i], 'hex')}`\n      argString += `${methodArgs[i]}`\n    } else {\n      argString += `${methodArgs[i]}`\n    }\n\n    dataString += argString\n\n    if ((inputs.length - 1) !== i) {\n      dataString += `, `\n    }\n  }\n  return dataString += `)`\n}\n\nexport interface Factory {\n  at(address: string): ContractInterface\n}\n\nexport interface ContractInterface {\n  abi: ContractABI\n  address: string\n}\n\ninterface DynamicABI {\n  [method: string]: () => TransactionRequest\n}\nexport const ContractFactory = (encoder?: (tx: any, params? : any) => any) => (contractABI: ContractABI): Factory => {\n  return {\n    at: (address: string) : any => {\n      const functionCalls : DynamicABI = {}\n      getCallableMethodsFromABI(contractABI).forEach((methodObject) => {\n        if (methodObject.name) {\n          functionCalls[methodObject.name] = function contractMethod() {\n            let providedTxObject = {};\n            const methodArgs = [].slice.call(arguments);\n            const nArgs = (methodObject.inputs || []).length\n            // Remove transaction object if provided\n            if (isTransactionObject(methodArgs[nArgs])) {\n              providedTxObject = methodArgs.splice(nArgs, 1)[0]\n            }\n\n            const methodTxObject = {\n              ...providedTxObject,\n              to: address,\n              function: encodeMethodReadable(methodObject, methodArgs)\n            }\n            if (!encoder) return methodTxObject\n\n            const extendArgs = methodArgs[methodArgs.length - 1]\n            return encoder(methodTxObject, extendArgs)\n          }  \n        }\n      })\n      return { ...functionCalls, abi: contractABI, address }\n    }\n  }\n}\n\n","import { ec as EC } from 'elliptic'\n\nimport { createJWT, verifyJWT, SimpleSigner, Signer, toEthereumAddress } from 'did-jwt'\nimport UportDIDResolver from 'uport-did-resolver'\nimport EthrDIDResolver from 'ethr-did-resolver'\nimport HttpsDIDResolver from 'https-did-resolver'\nimport UportLite from 'uport-lite'\nimport { isMNID, decode as mnidDecode } from 'mnid'\n\nimport {\n  ContractFactory,\n  TransactionRequest,\n  AbiParam,\n  ContractABI,\n  ContractInterface,\n  Factory\n} from './Contract'\nimport { DIDDocument, PublicKey } from 'did-resolver'\n\nconst secp256k1 = new EC('secp256k1')\n\nenum Types {\n  DISCLOSURE_REQUEST = 'shareReq',\n  DISCLOSURE_RESPONSE = 'shareResp',\n  TYPED_DATA_SIGNATURE_REQUEST = 'eip712Req',\n  VERIFICATION_SIGNATURE_REQUEST = 'verReq',\n  ETH_TX_REQUEST = 'ethtx',\n  PERSONAL_SIGN_REQUEST = 'personalSigReq'\n}\n\ninterface Network {\n  registry: string\n  rpcUrl: string\n}\ninterface Networks {\n  [net: string]: Network\n}\n\ninterface Settings {\n  did?: string\n  address?: string\n  privateKey?: string\n  signer?: Signer\n  networks?: Networks\n  registry?: (mnid: string) => Promise<object>\n  ethrConfig?: any\n}\n\ninterface Identity {\n  did: string\n  privateKey: string\n}\n\ninterface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string\n  iat?: number\n  type?: string\n  exp?: number\n}\n\ninterface ClaimSpec {\n  essential?: boolean\n  reason?: string\n}\n\ninterface IssuerSpec {\n  did: string\n  url?: string\n}\n\ninterface VerifiableClaimSpec extends ClaimSpec {\n  iss: IssuerSpec[]\n}\n\ninterface VerifiableClaimsSpec {\n  [claimType: string]: VerifiableClaimSpec\n}\n\n\ninterface UserInfoSpec {\n  [claimType: string]: ClaimSpec|null\n}\n\ninterface ClaimsSpec {\n  verifiable: VerifiableClaimsSpec\n  user_info: UserInfoSpec\n}\ninterface DisclosureRequestParams {\n  claims?: ClaimsSpec,\n  requested?: string[]\n  verified?: string[]\n  notifications?: boolean\n  callbackUrl?: string\n  networkId?: string\n  rpcUrl?: string\n  vc?: string[]\n  exp?: number\n  accountType?: 'none' | 'segregated' | 'keypair' | 'none',\n}\n\ninterface DisclosureRequestPayload extends JWTPayload{\n  claims?: ClaimsSpec,\n  requested?: string[]\n  verified?: string[]\n  permissions?: string[]\n  callback?: string\n  net?: string\n  rpc?: string\n  vc?: string[]\n  act?: 'none' | 'segregated' | 'keypair' | 'none'\n}\n\ninterface DisclosureResponsePayload extends JWTPayload {\n  req?: string\n  own?: any\n  verified?: string[]\n  nad?: string\n  dad?: string\n  boxPub?: string\n  capabilities?: string[]\n}\n\ninterface DisclosurePayload {\n  payload: DisclosureResponsePayload\n  doc: DIDDocument\n}\n\ninterface DisclosureResponse {\n  own: any\n  capabilities: string[]\n  aud?: string\n  req?: string\n  iat: number\n  exp?: number\n  type: Types.DISCLOSURE_RESPONSE\n  mnid?: string\n  address?: string\n  pushToken?: string\n  deviceKey?: string\n  did: string\n  verified?: Verification[]\n  invalid?: string[]\n  boxPub?: string\n}\n\ninterface VerifiedJWT {\n  payload: any\n  doc: DIDDocument\n  issuer: string\n  signer: PublicKey\n  jwt: string\n}\ninterface Verification extends JWTPayload {\n  claims: any\n  jwt?: string\n}\n\ninterface VerificationParam {\n  sub: string\n  claim: any\n  exp?: number\n  vc?: string[]\n  callbackUrl?: string\n}\n\ninterface VerificationRequest {\n  aud?: string\n  sub: string\n  riss?: string\n  rexp?: number\n  expiresIn?: number\n  vc?: string[]\n  callbackUrl?: string\n}\n\ninterface EIP712Domain {\n  name: string\n  version: string\n  chainId?: number\n  verifyingContract?: string\n  salt?: string\n}\n\ninterface EIP712Types {\n  EIP712Domain: AbiParam[]\n  [name: string]: AbiParam[]\n}\n\ninterface EIP712Object {\n  types: EIP712Types\n  domain: EIP712Domain\n  primaryType: string\n  message: any\n}\n\ninterface NetworkRequest {\n  from?: string\n  net?: string\n  callback?: string\n}\n\ninterface TxReqOptions {\n  callbackUrl?: string\n  exp?: number\n  networkId?: string\n  label?: string\n}\n\ninterface TxReqPayload {\n  callback?: string\n  net?: string\n  label?: string\n}\n\ninterface PersonalSignPayload {\n  callback?: string\n  from?: string\n  net?: string\n  data: string\n}\n\n/**\n * The Credentials class allows you to easily create the signed payloads used in uPort including\n * credentials and signed mobile app requests (ex. selective disclosure requests\n * for private data). It also provides signature verification over signed payloads.\n */\nclass Credentials {\n  /**\n   * Generate a DID and private key, effectively creating a new identity that can sign and verify data\n   *\n   * ```javascript\n   * const {did, privateKey} = Credentials.createIdentity()\n   * const credentials = new Credentials({did, privateKey, ...})\n   * ```\n   *\n   * @returns {Object} keypair\n   */\n  static createIdentity(): Identity {\n    const kp = secp256k1.genKeyPair()\n    const publicKey = <string>kp.getPublic('hex')\n    const privateKey = <string>kp.getPrivate('hex')\n    const address = toEthereumAddress(publicKey)\n    const did = `did:ethr:${address}`\n    return { did, privateKey }\n  }\n\n  readonly did?: string\n  readonly signer?: Signer\n\n  /**\n   * Instantiates a new uPort Credentials object\n   *\n   * The following example is just for testing purposes. *You should never store a private key in source code.*\n   *\n   * ```javascript\n   * import { Credentials } from 'uport-credentials'\n   * const credentials = new Credentials({\n   *   privateKey: '74894f8853f90e6e3d6dfdd343eb0eb70cca06e552ed8af80adadcc573b35da3'\n   * })\n   * ```\n   *\n   * The above example derives the public key used to generate the did, so only a private key is needed.\n   * Generating a public key from a private key is slow. It is recommended to configure the `did` option as well.\n   *\n   * ```javascript\n   * import { Credentials } from 'uport-credentials'\n   * const credentials = new Credentials({\n   *   did: 'did:ethr:0xbc3ae59bc76f894822622cdef7a2018dbe353840',\n   *   privateKey: '74894f8853f90e6e3d6dfdd343eb0eb70cca06e552ed8af80adadcc573b35da3'\n   * })\n   * ```\n   *\n   * It is recommended to store the address and private key in environment variables for your server application\n   *\n   * ```javascript\n   * import { Credentials, SimpleSigner } from 'uport-credentials'\n   * const credentials = new Credentials({\n   *   did: process.env.APPLICATION_DID,\n   *   signer: SimpleSigner(process.env.PRIVATE_KEY)\n   * })\n   * ```\n   *\n   * Instead of a private key you can pass in a [Signer Functions](https://github.com/uport-project/did-jwt#signer-functions) to\n   * present UX or call a HSM.\n   *\n   * ```javascript\n   * import { Credentials } from 'uport-credentials'\n   *\n   * function mySigner (data) {\n   *   return new Promise((resolve, reject) => {\n   *     const signature = /// sign it\n   *     resolve(signature)\n   *   })\n   * }\n   *\n   * const credentials = new Credentials({\n   *   did: process.env.APPLICATION_DID,\n   *   signer: mySigner\n   * })\n   * ```\n   *\n   * @param       {Object}            [settings]               optional setttings\n   * @param       {DID}               [settings.did]           Application\n   * [DID](https://w3c-ccg.github.io/did-spec/#decentralized-identifiers-dids) (unique identifier) for your application\n   * @param       {String}            [settings.privateKey]    A hex encoded 32 byte private key\n   * @param       {SimpleSigner}      [settings.signer]        a signer object, see\n   * [Signer Functions](https://github.com/uport-project/did-jwt#signer-functions)\n   * @param       {Object}            [settings.ethrConfig]    Configuration object for ethr did resolver. See\n   * [ethr-did-resolver](https://github.com/uport-project/ethr-did-resolver)\n   * @param       {Address}           [settings.address]       DEPRECATED your uPort address (may be the address of your\n   * application's uPort identity)\n   * @param       {Object}            [settings.networks]      DEPRECATED networks config object, ie. {  '0x94365e3b': {\n   * rpcUrl: 'https://private.chain/rpc', address: '0x0101.... }}\n   * @param       {UportLite}         [settings.registry]      DEPRECATED a registry object from UportLite\n   * @return      {Credentials}                                self\n   */\n  constructor({\n    did,\n    address,\n    privateKey,\n    signer,\n    networks,\n    registry,\n    ethrConfig\n  }: Settings) {\n    if (signer) {\n      this.signer = signer\n    } else if (privateKey) {\n      this.signer = SimpleSigner(privateKey)\n    }\n\n    if (did) {\n      this.did = did\n    } else if (address) {\n      if (isMNID(address)) {\n        this.did = `did:uport:${address}`\n      }\n      if (address.match('^0x[0-9a-fA-F]{40}$')) {\n        this.did = `did:ethr:${address}`\n      }\n    } else if (privateKey) {\n      const kp = secp256k1.keyFromPrivate(privateKey)\n      const address = toEthereumAddress(kp.getPublic('hex'))\n      this.did = `did:ethr:${address}`\n    }\n\n    UportDIDResolver(\n      registry ||\n        UportLite({ networks: networks ? configNetworks(networks) : {} })\n    )\n    EthrDIDResolver(ethrConfig || {})\n    HttpsDIDResolver()\n  }\n\n  signJWT(payload: object, expiresIn?: number) {\n    if (!(this.did && this.signer))\n      return Promise.reject(new Error('No Signing Identity configured'))\n    return createJWT(payload, {\n      issuer: this.did,\n      signer: this.signer,\n      alg:\n        this.did.match('^did:uport:') || isMNID(this.did)\n          ? 'ES256K'\n          : 'ES256K-R',\n      expiresIn\n    })\n  }\n\n  /**\n   *  Creates a [Selective Disclosure Request JWT](https://github.com/uport-project/specs/blob/develop/messages/sharereq.md)\n   *\n   *  ```javascript\n   *  const req = { claims: {\n   *      verifiable: {\n   *        email: {\n   *          iss: [\n   *            {\n   *              did: 'did:web:uport.claims',\n   *              url: 'https://uport.claims/email'\n   *            },\n   *            {\n   *              did: 'did:web:sobol.io',\n   *              url: 'https://sobol.io/verify'\n   *            }\n   *          ],\n   *          reason: 'Whe need to be able to email you'\n   *        },\n   *        nationalIdentity: {\n   *          essential: true,\n   *          iss: [\n   *            {\n   *              did: 'did:web:idverifier.claims',\n   *              url: 'https://idverifier.example'\n   *            }\n   *          ],\n   *          reason: 'To legally be able to open your account'\n   *        }\n   *      },\n   *      user_info: {\n   *        name: { essential: true, reason: \"Show your name to other users\"},\n   *        country: null\n   *      }\n   *    },\n   *    callbackUrl: 'https://myserver.com',\n   *    notifications: true }\n   *  credentials.createDisclosureRequest(req).then(jwt => {\n   *      ...\n   *  })\n   * `\n   *\n   *  @param    {Object}             [params={}]           request params object\n   * \n   *  @param    {Array}              params.requested      DEPRECATED an array of attributes for which you are requesting credentials to be shared for\n   *  @param    {Array}              params.verified       DEPRECATED an array of attributes for which you are requesting verified credentials to be shared for\n   *  @param    {Object}             params.claims         Claims spec Object\n   *  @param    {Boolean}            params.notifications  boolean if you want to request the ability to send push notifications\n   *  @param    {String}             params.callbackUrl    the url which you want to receive the response of this request\n   *  @param    {String}             params.networkId      network id of Ethereum chain of identity eg. 0x4 for rinkeby\n   *  @param    {String}             params.rpcUrl         JSON RPC url for use with account connecting to non standard\n   * (private or permissioned chain). The JSON-RPC url must match the `networkId`\n   *  @param    {String[]}           params.vc            An array of JWTs about the requester, signed by 3rd parties\n   *  @param    {String}             params.accountType    Ethereum account type: \"general\", \"segregated\", \"keypair\", or \"none\"\n   *  @param    {Number}             expiresIn             Seconds until expiry\n   *  @return   {Promise<Object, Error>}                   a promise which resolves with a signed JSON Web Token or rejects with an error\n   */\n  createDisclosureRequest(\n    params: DisclosureRequestParams = {},\n    expiresIn = 600\n  ) {\n    const payload: DisclosureRequestPayload = {}\n    if (params.requested) payload.requested = params.requested\n    if (params.verified) payload.verified = params.verified\n    if (params.claims) payload.claims = params.claims\n    if (params.notifications) payload.permissions = ['notifications']\n    if (params.callbackUrl) payload.callback = params.callbackUrl\n    if (params.networkId) payload.net = params.networkId\n    if (params.rpcUrl) {\n      if (params.networkId) {\n        payload.rpc = params.rpcUrl\n      } else {\n        return Promise.reject(\n          new Error(`rpcUrl was specified but no networkId`)\n        )\n      }\n    }\n    if (params.vc) payload.vc = params.vc\n    if (params.exp) payload.exp = params.exp\n\n    if (params.accountType) {\n      if (\n        ['general', 'segregated', 'keypair', 'none'].indexOf(\n          params.accountType\n        ) >= 0\n      ) {\n        payload.act = params.accountType\n      } else {\n        return Promise.reject(\n          new Error(`Unsupported accountType ${params.accountType}`)\n        )\n      }\n    }\n\n    return this.signJWT(\n      { ...payload, type: Types.DISCLOSURE_REQUEST },\n      params.exp ? undefined : expiresIn\n    )\n  }\n\n  /**\n   *  Create a credential (a signed JSON Web Token)\n   *\n   *  ```javascript\n   *  credentials.createVerification({\n   *   sub: '5A8bRWU3F7j3REx3vkJ...', // uPort address of user, likely a MNID\n   *   exp: <future timestamp>,\n   *   claim: { name: 'John Smith' }\n   *  }).then( credential => {\n   *   ...\n   *  })\n   * ```\n   *\n   * @param    {Object}            [credential]           a unsigned claim object\n   * @param    {String}            credential.sub         subject of credential (a valid DID)\n   * @param    {String}            credential.claim       claim about subject single key value or key mapping to object with multiple values (ie { address: {street: ..., zip: ..., country: ...}})\n   * @param    {String}            credential.exp         time at which this claim expires and is no longer valid (seconds since epoch)\n   * @return   {Promise<Object, Error>}                   a promise which resolves with a credential (JWT) or rejects with an error\n   */\n  createVerification({ sub, claim, exp, vc, callbackUrl }: VerificationParam) {\n    return this.signJWT({ sub, claim, exp, vc, callbackUrl })\n  }\n\n  /**\n   *  Creates a request a for a DID to [sign a verification](https://github.com/uport-project/specs/blob/develop/messages/verificationreq.md)\n   *\n   *  ```javascript\n   *  const unsignedClaim = {\n   *    claim: {\n   *      \"Citizen of city X\": {\n   *        \"Allowed to vote\": true,\n   *        \"Document\": \"QmZZBBKPS2NWc6PMZbUk9zUHCo1SHKzQPPX4ndfwaYzmPW\"\n   *      }\n   *    },\n   *    sub: \"2oTvBxSGseWFqhstsEHgmCBi762FbcigK5u\"\n   *  }\n   *  const aud = '0x123...'\n   *  const sub = '0x456...'\n   *  const callbackUrl = 'https://my.cool.site/handleTheResponse'\n   *  credentials.createVerificationSignatureRequest(unsignedClaim, {aud, sub, callbackUrl}).then(jwt => {\n   *    // ...\n   *  })\n   * ```\n   *\n   * @param    {Object}      unsignedClaim       Unsigned claim object which you want the user to attest\n   * @param    {Object}      [opts]\n   * @param    {String}      [opts.aud]          The DID of the identity you want to sign the attestation\n   * @param    {String}      [opts.sub]          The DID which the unsigned claim is about\n   * @param    {String}      [opts.riss]         The DID of the identity you want to sign the Verified Claim\n   * @param    {String}      [opts.callbackUrl]  The url to receive the response of this request\n   * @param    {Object[]}    [opts.vc]           An array of JWTs about the requester, signed by 3rd parties\n   * @param    {Number}      [opts.rexp]         The duration in seconds after which the signed verification expires\n   * @param    {Number}      [opts.expiresIn]    The duration in seconds after which the request expires\n   * @returns  {Promise<Object, Error>}          A promise which resolves with a signed JSON Web Token or rejects with an error\n   */\n  createVerificationSignatureRequest(unsignedClaim: object, { aud, sub, riss, callbackUrl, vc, rexp, expiresIn}:VerificationRequest) {\n    return this.signJWT({\n      unsignedClaim,\n      sub,\n      riss,\n      aud,\n      vc,\n      callback: callbackUrl,\n      type: Types.VERIFICATION_SIGNATURE_REQUEST,\n      rexp,\n    }, expiresIn)\n  }\n\n  /**\n   * Create a JWT requesting a signature on a piece of structured/typed data conforming to\n   * the ERC712 specification\n   *\n   * ```javascript\n   * const data = { // A ERC712 Greeting Structure\n   *   types: {\n   *     EIP712Domain: [\n   *       {name: 'name', type: 'string'},\n   *       {name: 'version', type: 'string'},\n   *       {name: 'chainId', type: 'uint256'},\n   *       {name: 'verifyingContract', type: 'address'},\n   *       {name: 'salt', type: 'bytes32'}\n   *     ],\n   *     Greeting: [\n   *       {name: 'text', type: 'string'},\n   *       {name: 'subject', type: 'string'},\n   *     ]\n   *   },\n   *   domain: {\n   *     name: 'My dapp',\n   *     version: '1.0',\n   *     chainId: 1,\n   *     verifyingContract: '0xdeadbeef',\n   *     salt: '0x999999999910101010101010'\n   *   },\n   *   primaryType: 'Greeting',\n   *   message: {\n   *     text: 'Hello',\n   *     subject: 'World'\n   *   }\n   * }\n   *\n   * const from = '0xbeef4567' // Eth account you are asking to sign the claim\n   * const net = '0x1' // The network on which this address exists\n   * const callback = 'https://my.cool.site/handleTheResponse'\n   * const signRequestJWT = credentials.createTypedDataSignatureRequest(data, {from, net, callback})\n   * // Send the JWT to a client\n   * // ...\n   * ```\n   *\n   * @param {Object} typedData              the ERC712 data to sign\n   * @param {Object} opts                   additional options for the jwt\n   *   @param {String} opts.from            the ethereum address you want to sign the typed data\n   *   @param {Number|String} opts.net      the id of the network on which the {from} address exists\n   *   @param {String} opts.callback        callback URL to handle the response\n   * @returns {Promise<Object, Error>}      a promise which resolves to a signed JWT or rejects with an error\n   */\n  async createTypedDataSignatureRequest(\n    typedData: EIP712Object,\n    { from, net, callback }: NetworkRequest = {}\n  ) {\n    // Check if the typedData is a valid ERC712 request\n    for (const prop of ['types', 'primaryType', 'message', 'domain']) {\n      if (!typedData[prop])\n        throw new Error(`Invalid EIP712 Request, must include '${prop}'`)\n    }\n\n    return await this.signJWT({\n      typedData,\n      from,\n      net,\n      callback,\n      type: Types.TYPED_DATA_SIGNATURE_REQUEST\n    })\n  }\n\n  /**\n   * Create a JWT requesting an eth_sign/personal_sign from a user.\n   * @param {String} data hex encoded data to sign\n   * @param {Object} opts Additional options for request\n   * @returns {Promise<Object, Error>}\n   */\n  createPersonalSignRequest(\n    data: string,\n    { from, net, callback }: NetworkRequest = {}\n  ) {\n    return this.signJWT({\n      data,\n      from,\n      net,\n      callback,\n      type: Types.PERSONAL_SIGN_REQUEST\n    })\n  }\n\n  /**\n   *  Given a transaction object, similarly defined as the web3 transaction object,\n   *  it creates a JWT transaction request and appends addtional request options.\n   *\n   *  ```javascript\n   *  const txObject = {\n   *    to: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347',\n   *    value: '0.1',\n   *    fn: \"setStatus(string 'hello', bytes32 '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347')\",\n   *  }\n   *  connect.createTxRequest(txObject, {callbackUrl: 'http://mycb.domain'}).then(jwt => {\n   *    ...\n   *  })\n   * ```\n   *\n   *  @param    {Object}    txObj               A web3 style transaction object\n   *  @param    {Object}    [opts]\n   *  @param    {String}    [opts.callbackUrl]  The url to receive the response of this request\n   *  @param    {String}    [opts.exp]          Time at which this request expires and is no longer valid (seconds since epoch)\n   *  @param    {String}    [opts.networkId]    Network ID for which this transaction request is for\n   *  @param    {String}    [opts.label]\n   *  @return   {String}                        a transaction request jwt\n   */\n  createTxRequest(\n    txObj: TransactionRequest,\n    { callbackUrl, exp = 600, networkId, label }: TxReqOptions = {}\n  ) {\n    const payload: TxReqPayload = {}\n    if (callbackUrl) payload.callback = callbackUrl\n    if (networkId) payload.net = networkId\n    if (label) payload.label = label\n    return this.signJWT(\n      { ...payload, ...txObj, type: Types.ETH_TX_REQUEST },\n      exp\n    )\n  }\n\n  /**\n   * Creates a [Selective Disclosure Response JWT](https://github.com/uport-project/specs/blob/develop/messages/shareresp.md).\n   *\n   * This can either be used to share information about the signing identity or as the response to a\n   * [Selective Disclosure Flow](https://github.com/uport-project/specs/blob/develop/flows/selectivedisclosure.md),\n   * where it can be used to authenticate the identity.\n   *\n   *  ```javascript\n   *  credentials.createDisclosureResponse({own: {name: 'Lourdes Valentina Gomez'}}).then(jwt => {\n   *      ...\n   *  })\n   * ```\n   *\n   *  @param    {Object}             [payload={}]           request params object\n   *  @param    {JWT}                payload.req            A selective disclosure Request JWT if this is returned as part of an authentication flow\n   *  @param    {Object}             payload.own            An object of self attested claims about the signer (eg. name etc)\n   *  @param    {Array}              payload.verified       An array of attestation JWT's to include\n   *  @param    {MNID}               payload.nad            An ethereum address encoded as an [MNID](https://github.com/uport-project/mnid)\n   *  @param    {Array}              payload.capabilities   An array of capability JWT's to include\n   *  @return   {Promise<Object, Error>}                    a promise which resolves with a signed JSON Web Token or rejects with an error\n   */\n  async createDisclosureResponse(\n    payload: DisclosureResponsePayload = {},\n    expiresIn = 600\n  ) {\n    if (payload.req) {\n      const verified = await verifyJWT(payload.req)\n      if (verified.issuer) {\n        payload.aud = verified.issuer\n      }\n    }\n    return this.signJWT(\n      { ...payload, type: Types.DISCLOSURE_RESPONSE },\n      expiresIn\n    )\n  }\n\n  /**\n   * Parse a selective disclosure response, and verify signatures on each signed claim (\"verification\") included.\n   * This function renames and applies special handling to certain recognized key-value pairs, and preserves others\n   * untouched.\n   *\n   * @private @deprecated\n   * @param     {Object}             response           A selective disclosure response payload, with associated did doc\n   * @param     {Object}             response.payload   A selective disclosure response payload, with associated did doc\n   * @param     {Object}             response.doc\n   */\n  async processDisclosurePayload({\n    doc,\n    payload\n  }: DisclosurePayload): Promise<DisclosureResponse> {\n    // Extract known key-value pairs from payload\n    const {\n      own = {},\n      capabilities = [],\n      aud, // ignored\n      req, // ignored\n      iat, // ignored\n      exp, // ignored\n      type,\n      nad: mnid,\n      dad: deviceKey,\n      iss: did,\n      boxPub,\n      verified,\n      ...rest\n    } = payload\n\n    const { uportProfile = {} } = doc\n\n    // Combine doc and payload into a single object, changing the names of some keys\n    const processed: DisclosureResponse = {\n      did,\n      boxPub,\n      ...own,\n      ...uportProfile,\n      ...rest\n      // aud, req, iat, exp are intentionally left out\n    }\n\n    if (deviceKey) processed.deviceKey = deviceKey\n\n    if (mnid) {\n      processed.mnid = mnid\n      processed.address = mnidDecode(mnid).address\n    }\n\n    // Push notifications are the only supported capability at the moment\n    if (capabilities.length === 1) {\n      processed.pushToken = capabilities[0]\n    }\n\n    // Verify and decode each jwt included in the `verified` array,\n    // and return the verified property as an array of decoded objects.\n    // Return invalid jwts in the `invalid` array\n    if (verified) {\n      const invalid: string[] = []\n      const verifying: Array<Promise<undefined | VerifiedJWT>> = verified.map(\n        token =>\n          verifyJWT(token, { audience: this.did }).catch(() => {\n            invalid.push(token)\n            return Promise.resolve(undefined)\n          })\n      )\n\n      // Format payloads and remove invalid JWTs\n      const unfiltered = await Promise.all(verifying)\n      const verifications: Verification[] = []\n      unfiltered.forEach(item => {\n        if (item) {\n          verifications.push(<Verification>{ ...item.payload, jwt: item.jwt })\n        }\n      })\n      processed.verified = verifications\n\n      processed.invalid = invalid\n    }\n\n    return processed\n  }\n\n  /**\n   *  Authenticates [Selective Disclosure Response JWT](https://github.com/uport-project/specs/blob/develop/messages/shareresp.md) from uPort\n   *  client as part of the [Selective Disclosure Flow](https://github.com/uport-project/specs/blob/develop/flows/selectivedisclosure.md).\n   *\n   *  It Verifies and parses the given response token and verifies the challenge response flow.\n   *\n   *  ```javascript\n   *  const resToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....'\n   *  credentials.authenticateDisclosureResponse(resToken).then(res => {\n   *      const credentials = res.verified\n   *      const name =  res.name\n   *      ...\n   *  })\n   * ```\n   *\n   *  @param    {String}                  token                 a response token\n   *  @param    {String}                  [callbackUrl=null]    callbackUrl\n   *  @return   {Promise<Object, Error>}                        a promise which resolves with a parsed response or rejects with an error.\n   */\n  async authenticateDisclosureResponse(token: string, callbackUrl?: string) {\n    const { payload, doc }: DisclosurePayload = await verifyJWT(token, {\n      audience: this.did,\n      callbackUrl,\n      auth: true\n    })\n\n    if (payload.req) {\n      const challengeReq = await verifyJWT(payload.req, { audience: this.did })\n      const request: DisclosureRequestPayload = challengeReq.payload\n      if (request.type !== Types.DISCLOSURE_REQUEST) {\n        throw new Error(`Challenge payload type invalid: ${request.type}`)\n      } else {\n        return this.processDisclosurePayload({ payload, doc })\n      }\n    } else {\n      throw new Error('Challenge was not included in response')\n    }\n  }\n\n  /**\n   *  Verify and return profile from a [Selective Disclosure Response JWT](https://github.com/uport-project/specs/blob/develop/messages/shareresp.md).\n   *\n   * The main difference between this and `authenticateDisclosureResponse()` is that it does not verify the challenge.\n   * This can be used to verify user profiles that have been shared through other methods such as QR codes and messages.\n   *\n   * ```javascript\n   *  const resToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....'\n   *  credentials.verifyDisclosure(resToken).then(profile => {\n   *      const credentials = profile.verified\n   *      const name =  profile.name\n   *      ...\n   *  })\n   * ```\n   *\n   *  @param    {String}                  token                 a response token\n   *  @return   {Promise<Object, Error>}                        a promise which resolves with a parsed response or rejects with an error.\n   */\n  async verifyDisclosure(token: string) {\n    const { payload, doc } = await verifyJWT(token, { audience: this.did })\n    return this.processDisclosurePayload({ payload, doc })\n  }\n\n  /**\n   *  Builds and returns a contract object which can be used to interact with\n   *  a given contract. Similar to web3.eth.contract but with promises. Once specifying .at(address)\n   *  you can call the contract functions with this object. Each call will create a request.\n   *\n   *  @param    {Object}       abi          contract ABI\n   *  @return   {Object}                    contract object\n   */\n  contract(abi: ContractABI): Factory {\n    const txObjHandler = (txObj: TransactionRequest, opts?: TxReqOptions) => {\n      if (txObj.function) txObj.fn = txObj.function\n      delete txObj['function']\n      return this.createTxRequest(txObj, opts)\n    }\n    return ContractFactory(txObjHandler.bind(this))(abi)\n  }\n}\n\nfunction configNetworks(nets: Networks) {\n  Object.keys(nets).forEach(key => {\n    const net = nets[key]\n    if (typeof net === 'object') {\n      ;['registry', 'rpcUrl'].forEach(key => {\n        if (!net.hasOwnProperty(key)) {\n          throw new Error(\n            `Malformed network config object, object must have '${key}' key specified.`\n          )\n        }\n      })\n    } else {\n      throw new Error(`Network configuration object required`)\n    }\n  })\n  return nets\n}\n\nexport default Credentials\n"],"names":["AbiEntryType","StateMutability","const","Types","encodeMethodReadable","methodObject","methodArgs","dataString","inputs","i","length","input","argString","type","ContractFactory","encoder","contractABI","at","address","functionCalls","filter","entry","Function","name","constant","getCallableMethodsFromABI","forEach","providedTxObject","slice","call","arguments","nArgs","txObj","Object","keys","isTransactionObject","splice","methodTxObject","to","function","abi","secp256k1","EC","Credentials","constructor","ref","nets","signer","privateKey","SimpleSigner","did","isMNID","match","kp","keyFromPrivate","toEthereumAddress","getPublic","UportDIDResolver","registry","UportLite","networks","key","net","Error","hasOwnProperty","EthrDIDResolver","ethrConfig","signJWT","createIdentity","genKeyPair","publicKey","getPrivate","payload","expiresIn","this","createJWT","issuer","Promise","reject","createDisclosureRequest","params","requested","verified","claims","notifications","permissions","callbackUrl","callback","networkId","rpcUrl","rpc","vc","exp","accountType","indexOf","act","DISCLOSURE_REQUEST","undefined","createVerification","createVerificationSignatureRequest","unsignedClaim","VERIFICATION_SIGNATURE_REQUEST","createTypedDataSignatureRequest","typedData","prop","from","TYPED_DATA_SIGNATURE_REQUEST","createPersonalSignRequest","data","PERSONAL_SIGN_REQUEST","createTxRequest","label","ETH_TX_REQUEST","createDisclosureResponse","_this2","DISCLOSURE_RESPONSE","req","verifyJWT","aud","processDisclosurePayload","mnid","processed","boxPub","own","uportProfile","deviceKey","mnidDecode","capabilities","pushToken","invalid","verifying","map","token","audience","_this3","catch","push","resolve","all","unfiltered","verifications","item","jwt","authenticateDisclosureResponse","_this4","challengeReq","request","doc","verifyDisclosure","_this5","contract","opts","fn","bind"],"mappings":"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"}