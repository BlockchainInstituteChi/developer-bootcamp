'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.send = exports.chasquiCompress = exports.chasquiSend = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _nets = require('nets');

var _nets2 = _interopRequireDefault(_nets);

var _ui = require('./ui');

var _util = require('./../message/util.js');

var _messageServer = require('./messageServer');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var POLLING_INTERVAL = 2000;

/**
 * A QR tranpsort which uses our provided QR modal to relay a request to a uPort client,
 * optionally compressing the provided message if a compress function is provided
 *
 * @param    {String}       displayText   dialog used in qr modal display
 * @return   {Function}                   a configured QRTransport Function
 *   @param    {String}       message            a uport client request message
 *   @param    {Object}       [opts={}]
 *   @param    {Function}     [opts.cancel]      cancel callback, called on modal close
 *   @param    {Function}     [opts.compress]    a function to compress a JWT, returning a promise that resolves to a string
 *   @return   {Function}                        a function to close the QR modal
 */
var send = function send(displayText) {
  return function (message) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        cancel = _ref.cancel,
        compress = _ref.compress;

    if (compress) {
      compress(message).then(function (msg) {
        return (0, _ui.open)(msg, cancel, displayText);
      }).catch(function (err) {
        console.error(err);
        // Display failure modal and allow retry
        (0, _ui.failure)(function () {
          return send(displayText)(message, { cancel: cancel, compress: compress });
        });
      });
    } else {
      var uri = (0, _util.messageToURI)(message);
      uri = /callback_type=/.test(uri) ? uri : (0, _util.paramsToQueryString)(uri, { callback_type: 'post' });
      (0, _ui.open)(uri, cancel, displayText);
    }

    // Return close function immediately, UI is async anyway
    return _ui.close;
  };
};

/**
 * A utility function for reducing the size of a QR code by uploading it to chasqui and
 * replacing the contents with the topic url.
 *
 * An empty Verification JWT (i.e. with signature and sub/iss but blank claim) is ~250 characters
 * The absolute max that can fit in a scanable QR on the screen is ~1500 characters
 * Below 650 characters the QR modal fits perfectly in the browser on a 13" MBP, with some wiggle room
 *
 * @param   {String}  message     the request JWT
 * @param   {Number}  threshold   the smallest size (in string length) to compress
 * @returns {String}  the chasqui url of the message, or the original message if less than threshold
 */
var chasquiCompress = function chasquiCompress(message) {
  var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

  return new Promise(function (resolve, reject) {
    if (message.length < threshold) {
      var uri = (0, _util.messageToURI)(message);
      uri = /callback_type=/.test(uri) ? uri : (0, _util.paramsToQueryString)(uri, { callback_type: 'post' });
      resolve(uri);
      return;
    }
    // Trim message and extract query params
    var topic = _extends({
      message: message.replace(/\?.*/, '')
    }, (0, _util.getUrlQueryParams)(message));
    (0, _nets2.default)({
      uri: _messageServer.CHASQUI_URL + 'topic/',
      method: 'POST',
      body: JSON.stringify(topic),
      headers: {
        'content-type': 'application/json'
      },
      withCredentials: false,
      rejectUnauthorized: false
    }, function (err, response) {
      if (err) reject(err);else if (response.statusCode !== 201) reject(new Error('Failed to create topic'));else {
        var _uri = '' + _messageServer.CHASQUI_URL + (response.headers.location || response.headers.Location);
        resolve(_uri);
      }
    });
  });
};

/**
 *  A QR Code and Chasqui Transport. The QR modal is configured for tranporting the request, while the
 *  response will be returned through Chasqui.
 *
 *  @param    {Object}       [config={}]               an optional config object
 *  @param    {String}       [config.chasquiUrl]       url of messaging server, defaults to Chasqui instance run by uPort
 *  @param    {String}       [config.pollingInterval]  milisecond interval at which the messaging server will be polled for a response
 *  @return   {Function}                               a configured QRTransport Function
 *  @param    {String}       message                   a uPort client request message
 *  @return   {Promise<Object, Error>}                 a function to close the QR modal
 */
var chasquiSend = function chasquiSend() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$chasquiUrl = _ref2.chasquiUrl,
      chasquiUrl = _ref2$chasquiUrl === undefined ? _messageServer.CHASQUI_URL : _ref2$chasquiUrl,
      _ref2$pollingInterval = _ref2.pollingInterval,
      pollingInterval = _ref2$pollingInterval === undefined ? POLLING_INTERVAL : _ref2$pollingInterval,
      displayText = _ref2.displayText;

  var transport = (0, _messageServer.URIHandlerSend)(send(displayText, { compress: chasquiCompress }), { chasquiUrl: chasquiUrl, pollingInterval: pollingInterval });
  return function (message, params) {
    return transport(message, params).then(function (res) {
      (0, _ui.close)();
      return res;
    }, function (err) {
      (0, _ui.close)();
      throw new Error(err);
    });
  };
};

exports.chasquiSend = chasquiSend;
exports.chasquiCompress = chasquiCompress;
exports.send = send;