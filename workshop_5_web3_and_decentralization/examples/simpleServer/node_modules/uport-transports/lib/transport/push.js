'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendAndNotify = exports.send = undefined;

var _nets = require('nets');

var _nets2 = _interopRequireDefault(_nets);

var _crypto = require('../crypto');

var _util = require('../message/util');

var _ui = require('./ui');

var _qr = require('./qr');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PUTUTU_URL = 'https://api.uport.me/pututu/sns';

/**
 *  A push notification transport for pushing requests to the uPort mobile client of a specific user
 *  for which you have been given a valid push token.
 *
 *  @param    {String}      token              a push notification token (get a pn token by requesting push permissions in a request)
 *  @param    {String}      pubEncKey          the public encryption key of the receiver, encoded as a base64 string, found in a DID document
 *  @param    {String}      [pushServiceUrl=PUTUTU_URL] the url of the push service, by default it is PUTUTU at https://api.uport.me/pututu/sns/
 *  @return   {Function}                       a configured Push transport function
 *  @param    {String}      message            a uport client request message
 *  @param    {Object}      [opts={}]          an optional config object
 *  @param    {String}      opts.type          specifies callback type 'post' or 'redirect' for response
 *  @param    {String}      opts.redirectUrl   specifies url which a uport client will return to control once the request is handled, depending on request type it may or may not be returned with the response as well.
 *  @return   {Promise<Object, Error>}         a promise which resolves with successful push notification status or rejects with an error
 */
var send = function send(token, pubEncKey) {
  var pushServiceUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PUTUTU_URL;

  if (!token) throw new Error('Requires push notification token');
  if (!pubEncKey) throw new Error('Requires public encryption key of the receiver');

  return function (message) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        type = _ref.type,
        redirectUrl = _ref.redirectUrl;

    return new Promise(function (resolve, reject) {
      if (!message) return reject(new Error('Requires message request to send'));
      // TODO will need following comments if mobile consumes these url params instead of just request message/token
      // let url = messageToURI(reqMessage)
      // if (type) url = paramsToQueryString(url, {callback_type: type})
      // if (redirectUrl) url = paramsToQueryString(url, {'redirect_url': redirectUrl})
      message = (0, _util.getURLJWT)(message);
      var reqObj = { message: message };
      var plaintext = padMessage(JSON.stringify(reqObj));
      var enc = (0, _crypto.encryptMessage)(plaintext, pubEncKey);
      var payload = { message: JSON.stringify(enc) };
      (0, _nets2.default)({
        uri: pushServiceUrl,
        json: payload,
        method: 'POST',
        withCredentials: false,
        headers: {
          Authorization: 'Bearer ' + token
        }
      }, function (error, res, body) {
        if (error) return reject(error);
        if (res.statusCode === 200) return resolve(body);
        if (res.statusCode === 403) {
          return reject(new Error('Error sending push notification to user: Invalid Token'));
        }
        reject(new Error('Error sending push notification to user: ' + res.statusCode + ' ' + body.toString()));
      });
    });
  };
};

/**
 * The same transport as above, but also display a self-dismissing modal notifying
 * the user that push notification has been sent to their device
 * @see send
 */
var sendAndNotify = function sendAndNotify(token, pubEncKey) {
  var pushServiceUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PUTUTU_URL;

  var FALLBACK_MESSAGE = 'Scan QR Code Instead:';
  var sendPush = send(token, pubEncKey, pushServiceUrl);
  return function (message, params) {
    (0, _ui.notifyPushSent)(function () {
      return (0, _qr.send)(FALLBACK_MESSAGE)(message);
    });
    return sendPush(message, params);
  };
};

/**
 *  Adds padding to a string
 *
 *  @param      {String}   message    the message to be padded
 *  @return     {String}              the padded message
 *  @private
 */
var padMessage = function padMessage(message) {
  var INTERVAL_LENGTH = 50;
  var padLength = INTERVAL_LENGTH - message.length % INTERVAL_LENGTH;
  return message + ' '.repeat(padLength);
};

exports.send = send;
exports.sendAndNotify = sendAndNotify;