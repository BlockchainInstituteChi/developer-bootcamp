'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _nets = require('nets');

var _nets2 = _interopRequireDefault(_nets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var POLLING_INTERVAL = 2000;

/**
 *  A general polling function. Polls a given url and parse message according to given parsing functions, promise resolves on response or error.
 *
 *  @param    {String}                  url                url polled
 *  @param    {Function}                messageParse       function that parses response from get request, also determines if response is available to decide to continue polling or not
 *  @param    {Function}                errorParse         function that parses response from get request and determines if error was returned.
 *  @param    {Integer}                 [pollingInterval]  ms interval at which the given url is polled
 *  @param    {Function}                [cancelled]        function which returns boolean, if returns true, polling stops
 *  @return   {Promise<Object, Error>}                     a promise which resolves with obj/message or rejects with an error
 */
var poll = function poll(url, messageParse, errorParse) {
  var cancelled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {
    return false;
  };
  var pollingInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : POLLING_INTERVAL;
  return new Promise(function (resolve, reject) {
    var interval = setInterval(function () {
      (0, _nets2.default)({
        uri: url,
        json: true,
        method: 'GET',
        withCredentials: false,
        rejectUnauthorized: false
      }, function (err, res, body) {
        if (err) return reject(err);

        if (cancelled()) {
          clearInterval(interval);
          return reject(new Error('Request Cancelled'));
        }
        try {
          var messageError = errorParse(body);
          var message = messageParse(body);
          if (messageError) {
            clearInterval(interval);
            return reject(messageError);
          }
          if (message) {
            clearInterval(interval);
            return resolve(message);
          }
        } catch (err) {
          clearInterval(interval);
          return reject(err);
        }
      });
    }, pollingInterval);
  });
};

exports.default = poll;