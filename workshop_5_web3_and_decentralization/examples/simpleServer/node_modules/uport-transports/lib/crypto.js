'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpad = exports.pad = exports.decryptResponse = exports.decryptMessage = exports.encryptMessage = exports.randomString = exports.ASYNC_ENC_ALGORITHM = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _tweetnacl = require('tweetnacl');

var _tweetnacl2 = _interopRequireDefault(_tweetnacl);

var _tweetnaclUtil = require('tweetnacl-util');

var _tweetnaclUtil2 = _interopRequireDefault(_tweetnaclUtil);

var _base64url = require('base64url');

var _base64url2 = _interopRequireDefault(_base64url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ASYNC_ENC_ALGORITHM = exports.ASYNC_ENC_ALGORITHM = 'x25519-xsalsa20-poly1305';
var BLOCK_SIZE = 64;

function pad(message) {
  var paddedSize = Math.ceil(message.length / BLOCK_SIZE) * BLOCK_SIZE;
  // use `String.prototype.padEnd()` if available
  if (typeof message.padEnd === 'function') return message.padEnd(paddedSize, '\0');
  var padded = message;
  while (padded.length < paddedSize) {
    padded += '\0';
  }
  return padded;
}

function unpad(padded) {
  return padded.replace(/\0+$/, '');
}

/**
 *  Given a length, returns a random string of that length
 *
 *  @param    {Integer}                 length    specify length of string returned
 *  @return   {String}                            random string
 */
function randomString(length) {
  return _base64url2.default.fromBase64(_tweetnaclUtil2.default.encodeBase64(_tweetnacl2.default.randomBytes(length)));
}

/**
 *  Encrypts a message
 *
 *  @param      {String}   message    the message to be encrypted
 *  @param      {String}   boxPub     the public encryption key of the receiver, encoded as base64
 *  @return     {Object}              the encrypted message as an object containing a `version`, `nonce`, `ephemPublicKey` and `ciphertext`
 *  @private
 */
function encryptMessage(message, boxPub) {
  var _nacl$box$keyPair = _tweetnacl2.default.box.keyPair(),
      publicKey = _nacl$box$keyPair.publicKey,
      secretKey = _nacl$box$keyPair.secretKey;

  var nonce = _tweetnacl2.default.randomBytes(_tweetnacl2.default.box.nonceLength);
  var padded = pad(message);
  var ciphertext = _tweetnacl2.default.box(_tweetnaclUtil2.default.decodeUTF8(padded), nonce, _tweetnaclUtil2.default.decodeBase64(boxPub), secretKey);
  return {
    version: ASYNC_ENC_ALGORITHM,
    nonce: _tweetnaclUtil2.default.encodeBase64(nonce),
    ephemPublicKey: _tweetnaclUtil2.default.encodeBase64(publicKey),
    ciphertext: _tweetnaclUtil2.default.encodeBase64(ciphertext)
  };
}

/**
 *  Decrypts a message
 *
 *  @param      {Object} encrypted                   The encrypted message object
 *  @param      {String} encrypted.version           The string `x25519-xsalsa20-poly1305`
 *  @param      {String} encrypted.nonce             Base64 encoded nonce
 *  @param      {String} encrypted.ephemPublicKey    Base64 encoded ephemeral public key
 *  @param      {String} encrypted.ciphertext        Base64 encoded ciphertext
 *  @param      {String} secretKey                   The secret key as a Uint8Array
 *  @return     {String}                             The decrypted message
 *  @private
 */

function decryptMessage(_ref, secretKey) {
  var version = _ref.version,
      ciphertext = _ref.ciphertext,
      nonce = _ref.nonce,
      ephemPublicKey = _ref.ephemPublicKey;

  if (!secretKey) throw new Error('Encryption secret key has not been configured');
  if (version !== ASYNC_ENC_ALGORITHM) throw new Error('Unsupported encryption algorithm: ' + version);
  if (!(ciphertext && nonce && ephemPublicKey)) throw new Error('Invalid encrypted message');
  var decrypted = _tweetnacl2.default.box.open(_tweetnaclUtil2.default.decodeBase64(ciphertext), _tweetnaclUtil2.default.decodeBase64(nonce), _tweetnaclUtil2.default.decodeBase64(ephemPublicKey), secretKey);
  if (!decrypted) throw new Error('Could not decrypt message');
  return unpad(_tweetnaclUtil2.default.encodeUTF8(decrypted));
}

/**
 *  Decrypts a response from a promise. This is intended to be used to wrap the response from Chasqui or other transport
 *
 *  @param      {Object} encrypted                 The encrypted message object
 *  @param      {String} encrypted.version         The string `x25519-xsalsa20-poly1305`
 *  @param      {String} encrypted.nonce           Base64 encoded nonce
 *  @param      {String} encrypted.ephemPublicKey  Base64 encoded ephemeral public key
 *  @param      {String} encrypted.ciphertext      Base64 encoded ciphertext
 *  @param      {String} secretKey                 The secret key as a Uint8Array
 *  @return   {Promise<Object, Error>}             a promise which resolves with the decrypted message or rejects with an error
 */
function decryptResponse(response, secretKey) {
  return new Promise(function (resolve, reject) {
    if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) === 'object') {
      resolve(decryptMessage(response, secretKey));
    }
    resolve(response);
  });
}

exports.randomString = randomString;
exports.encryptMessage = encryptMessage;
exports.decryptMessage = decryptMessage;
exports.decryptResponse = decryptResponse;
exports.pad = pad;
exports.unpad = unpad;