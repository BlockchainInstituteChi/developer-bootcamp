{"version":3,"file":"resolver.umd.js","sources":["../src/resolver.ts"],"sourcesContent":["// Copyright 2018 ConsenSys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport interface DIDDocument {\n  '@context': 'https://w3id.org/did/v1'\n  id: string\n  publicKey: PublicKey[]\n  authentication?: Authentication[]\n  uportProfile?: any\n  service?: ServiceEndpoint[]\n}\n\nexport interface ServiceEndpoint {\n  id: string\n  type: string\n  serviceEndpoint: string\n  description?: string\n}\n\nexport interface PublicKey {\n  id: string\n  type: string\n  owner: string\n  ethereumAddress?: string\n  publicKeyBase64?: string\n  publicKeyBase58?: string\n  publicKeyHex?: string\n  publicKeyPem?: string\n}\n\nexport interface Authentication {\n  type: string\n  publicKey: string\n}\n\nexport interface Params {\n  [index: string]: string\n}\n\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver\n) => Promise<null | DIDDocument>\nexport type WrappedResolver = () => Promise<null | DIDDocument>\nexport type DIDCache = (\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n) => Promise<null | DIDDocument>\n\ninterface ResolverRegistry {\n  [index: string]: DIDResolver\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDDocument | null> = new Map()\n  return async (parsed, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true')\n      return await resolve()\n\n    const cached = cache.get(parsed.did)\n    if (cached !== undefined) return cached\n    const doc = await resolve()\n    cache.set(parsed.did, doc)\n    return doc\n  }\n}\n\nexport function noCache(\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n): Promise<null | DIDDocument> {\n  return resolve()\n}\n\nconst ID_CHAR = '[a-zA-Z0-9_.-]'\nconst METHOD = '([a-zA-Z0-9_]+)'\nconst METHOD_ID = `(${ID_CHAR}+(:${ID_CHAR}+)*)`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(\\/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(\\#.*)?`\nconst DID_MATCHER = new RegExp(\n  `^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`\n)\nexport function parse(didUrl: string): ParsedDID {\n  if (didUrl === '' || !didUrl) throw new Error('Missing DID')\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  throw new Error(`Invalid DID ${didUrl}`)\n}\n\nexport class Resolver {\n  private registry: ResolverRegistry\n  private cache: DIDCache\n\n  constructor(\n    registry: ResolverRegistry = {},\n    cache?: DIDCache | boolean | undefined\n  ) {\n    this.registry = registry\n    this.cache = cache === true ? inMemoryCache() : cache || noCache\n  }\n\n  resolve(didUrl: string): Promise<DIDDocument | null> {\n    try {\n      const parsed = parse(didUrl)\n      const resolver = this.registry[parsed.method]\n      if (resolver) {\n        return this.cache(parsed, () => resolver(parsed.did, parsed, this))\n      }\n      return Promise.reject(\n        new Error(`Unsupported DID method: '${parsed.method}'`)\n      )\n    } catch (error) {\n      return Promise.reject(error)\n    }\n  }\n}\n"],"names":["inMemoryCache","cache","Map","parsed","resolve","cached","get","did","undefined","doc","set","params","noCache","const","DID_MATCHER","RegExp","parse","didUrl","Error","sections","match","parts","method","id","slice","split","kv","path","query","fragment","Resolver","constructor","registry","resolver","this","Promise","reject","error"],"mappings":"0LA4EgBA,QACRC,EAAyC,IAAIC,oBACrCC,EAAQC,gDAIdC,EAASJ,EAAMK,IAAIH,EAAOI,iBACjBC,IAAXH,EAA6BA,kBACfD,mBAAZK,UACNR,EAAMS,IAAIP,EAAOI,IAAKE,GACfA,wBAPHN,EAAOQ,QAAwC,SAA9BR,EAAOQ,OAAO,wCACpBP,sGAUHQ,EACdT,EACAC,UAEOA,IAGTS,IASMC,EAAc,IAAIC,kJAGRC,EAAMC,MACL,KAAXA,IAAkBA,EAAQ,MAAM,IAAIC,MAAM,mBACxCC,EAAWF,EAAOG,MAAMN,MAC1BK,EAAU,KACNE,EAAmB,CACvBd,WAAYY,EAAS,OAAMA,EAAS,GACpCG,OAAQH,EAAS,GACjBI,GAAIJ,EAAS,UACbF,MAEEE,EAAS,GAAI,KACTR,EAASQ,EAAS,GAAGK,MAAM,GAAGC,MAAM,KAC1CJ,EAAMV,OAAS,OACV,UAAWA,kBAAQ,CAAnBE,IACGa,OAAOD,MAAM,KACnBJ,EAAMV,OAAOe,EAAG,IAAMA,EAAG,WAGzBP,EAAS,KAAIE,EAAMM,KAAOR,EAAS,IACnCA,EAAS,KAAIE,EAAMO,MAAQT,EAAS,GAAGK,MAAM,IAC7CL,EAAS,KAAIE,EAAMQ,SAAWV,EAAS,GAAGK,MAAM,IAC7CH,QAEH,IAAIH,qBAAqBD,OAGpBa,EAIXC,SACEC,EACA/B,kBAD6B,SAGxB+B,SAAWA,OACX/B,OAAkB,IAAVA,EAAiBD,IAAkBC,GAASW,GAG3DR,YAAAA,iBAAQa,sBAEEd,EAASa,EAAMC,GACfgB,EAAWC,KAAKF,SAAS7B,EAAOmB,eAClCW,EACKC,KAAKjC,MAAME,oBAAc8B,EAAS9B,EAAOI,IAAKJ,EAAQ+B,KAExDC,QAAQC,OACb,IAAIlB,kCAAkCf,eAExC,MAAOkC,UACAF,QAAQC,OAAOC"}